// ------------------------------------------------------------------------
//  Copyright 2025 The Dapr Authors
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//      http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//  ------------------------------------------------------------------------

using System.Buffers;
using System.Runtime.CompilerServices;
using Dapr.Common;
using Dapr.Cryptography.Extensions;
using Google.Protobuf;
using Grpc.Core;
using Dapr.Common.Extensions;
using P = Dapr.Client.Autogen.Grpc.v1.Dapr;
using Autogenerated = Dapr.Client.Autogen.Grpc.v1;

namespace Dapr.Cryptography.Encryption;

/// <summary>
/// A client for interacting with the Dapr cryptography encryption and decryption endpoints.
/// </summary>
internal sealed class DaprEncryptionGrpcClient(P.DaprClient client, HttpClient httpClient, string? daprApiToken) : DaprEncryptionClient
{
    /// <summary>
    /// The HTTP client used by the client for calling the Dapr runtime.
    /// </summary>
    /// <remarks>
    /// Property exposed for testing purposes.
    /// </remarks>
    internal readonly HttpClient HttpClient = httpClient;
    /// <summary>
    /// The Dapr API token value.
    /// </summary>
    /// <remarks>
    /// Property exposed for testing purposes.
    /// </remarks>
    internal readonly string? DaprApiToken = daprApiToken;
    
    /// <inheritdoc />
    [Obsolete(
        "The API is currently not stable as it is in the Alpha stage. This attribute will be removed once it is stable.")]
    public override async Task<ReadOnlyMemory<byte>> EncryptAsync(
        string vaultResourceName,
        ReadOnlyMemory<byte> plaintextBytes,
        string keyName,
        EncryptionOptions encryptionOptions,
        CancellationToken cancellationToken = default)
    {
        using var memoryStream = new MemoryStream(plaintextBytes.Length);
        await memoryStream.WriteAsync(plaintextBytes, cancellationToken);
        memoryStream.Position = 0;

        var encryptionResult =
            await EncryptAsync(vaultResourceName, memoryStream, keyName, encryptionOptions, cancellationToken);

        var bufferedResult = new ArrayBufferWriter<byte>();
        await foreach (var item in encryptionResult.WithCancellation(cancellationToken))
        {
            bufferedResult.Write(item.Span);
        }

        return bufferedResult.WrittenMemory;
    }

    /// <inheritdoc />
    [Obsolete(
        "The API is currently not stable as it is in the Alpha stage. This attribute will be removed once it is stable.")]
    public override async Task<IAsyncEnumerable<ReadOnlyMemory<byte>>> EncryptAsync(
        string vaultResourceName,
        Stream plaintextStream,
        string keyName,
        EncryptionOptions encryptionOptions,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(vaultResourceName, nameof(vaultResourceName));
        ArgumentException.ThrowIfNullOrEmpty(keyName, nameof(keyName));
        ArgumentNullException.ThrowIfNull(plaintextStream, nameof(plaintextStream));
        ArgumentNullException.ThrowIfNull(encryptionOptions, nameof(encryptionOptions));

        try
        {
            var shouldOmitDecryptionKeyName = string.IsNullOrWhiteSpace(encryptionOptions.DecryptionKeyName);

            var encryptionRequestOptions = new Autogenerated.EncryptRequestOptions
            {
                ComponentName = vaultResourceName,
                DataEncryptionCipher = encryptionOptions.EncryptionCipher.GetValueFromEnumMember(),
                KeyName = keyName,
                KeyWrapAlgorithm = encryptionOptions.KeyWrapAlgorithm.GetValueFromEnumMember(),
                OmitDecryptionKeyName = shouldOmitDecryptionKeyName
            };

            if (!shouldOmitDecryptionKeyName)
            {
                ArgumentException.ThrowIfNullOrEmpty(encryptionOptions.DecryptionKeyName,
                    nameof(encryptionOptions.DecryptionKeyName));
                encryptionRequestOptions.DecryptionKeyName = encryptionOptions.DecryptionKeyName;
            }

            var grpcCallOptions = DaprClientUtilities.ConfigureGrpcCallOptions(typeof(DaprEncryptionClient).Assembly,
                this.DaprApiToken, cancellationToken);
            var duplexStream = client.EncryptAlpha1(grpcCallOptions);

            var sendTask = Task.Run(() => SendPlaintextStreamAsync(plaintextStream,
                encryptionOptions.StreamingBlockSizeInBytes,
                duplexStream, encryptionRequestOptions, cancellationToken), cancellationToken);
            var receiveTask = Task.Run(() =>
                RetrieveEncryptedStreamAsync(duplexStream, cancellationToken), cancellationToken);

            await Task.WhenAll(sendTask, receiveTask).ConfigureAwait(false);
            return receiveTask.Result;
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
            //Ignore our own cancellation
            return AsyncEnumerableExtensions.Empty<ReadOnlyMemory<byte>>();
        }
        catch (RpcException ex) when (ex.StatusCode == StatusCode.Cancelled &&
                                      cancellationToken.IsCancellationRequested)
        {
            //Ignore a remote cancellation due to our own cancellation
            return AsyncEnumerableExtensions.Empty<ReadOnlyMemory<byte>>();
        }
        catch (Exception ex)
        {
            throw new DaprException("Encrypt operation failed: the Dapr endpoint indicated a failure. See InnerException for details.", ex);
        }
    }
    
    /// <summary>
    /// Sends the plaintext bytes in chunks to the sidecar to be encrypted.
    /// </summary>
    private static async ValueTask SendPlaintextStreamAsync(
        Stream plaintextStream,
        int streamingBlockSizeInBytes,
        AsyncDuplexStreamingCall<Autogenerated.EncryptRequest, Autogenerated.EncryptResponse> duplexStream,
        Autogenerated.EncryptRequestOptions encryptRequestOptions,
        CancellationToken cancellationToken)
    {
        //Start with passing the metadata about the encryption request itself in the first message
        await duplexStream.RequestStream.WriteAsync(new Autogenerated.EncryptRequest { Options = encryptRequestOptions }, cancellationToken);

        //Send the ciphertext bytes in blocks in subsequent messages
        await using (var bufferedStream = new BufferedStream(plaintextStream, streamingBlockSizeInBytes))
        {
            var buffer = ArrayPool<byte>.Shared.Rent(streamingBlockSizeInBytes);
            try
            {
                int bytesRead;
                ulong sequenceNumber = 0;

                while ((bytesRead =
                           await bufferedStream.ReadAsync(buffer.AsMemory(0, streamingBlockSizeInBytes),
                               cancellationToken)) != 0)
                {
                    await duplexStream.RequestStream.WriteAsync(
                        new Autogenerated.EncryptRequest
                        {
                            Payload = new Autogenerated.StreamPayload
                            {
                                Data = ByteString.CopyFrom(buffer, 0, bytesRead), Seq = sequenceNumber
                            }
                        }, cancellationToken);

                    //Increment the sequence number
                    sequenceNumber++;
                }
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }

        //Send the completion message
        await duplexStream.RequestStream.CompleteAsync();
    }

    /// <summary>
    /// Retrieves the encrypted bytes from the encryption options on the sidecar and returns as an
    /// enumerable stream.
    /// </summary>
    private static async IAsyncEnumerable<ReadOnlyMemory<byte>> RetrieveEncryptedStreamAsync(
        AsyncDuplexStreamingCall<Autogenerated.EncryptRequest, Autogenerated.EncryptResponse> duplexStream,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        await foreach (var encryptResponse in duplexStream.ResponseStream.ReadAllAsync(cancellationToken).ConfigureAwait(false))
        {
            yield return encryptResponse.Payload.Data.Memory;
        }
    }

    /// <inheritdoc />
    [Obsolete(
        "The API is currently not stable as it is in the Alpha stage. This attribute will be removed once it is stable.")]
    public override async Task<ReadOnlyMemory<byte>> DecryptAsync(
        string vaultResourceName,
        ReadOnlyMemory<byte> ciphertextBytes,
        string keyName,
        DecryptionOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        using var memoryStream = new MemoryStream(ciphertextBytes.Length);
        await memoryStream.WriteAsync(ciphertextBytes, cancellationToken);
        memoryStream.Position = 0;

        var decryptionResult = await DecryptAsync(vaultResourceName, memoryStream, keyName, options, cancellationToken);

        var bufferedResult = new ArrayBufferWriter<byte>();
        await foreach(var item in decryptionResult.WithCancellation(cancellationToken))
        {
            bufferedResult.Write(item.Span);
        }

        return bufferedResult.WrittenMemory;
    }

    /// <inheritdoc />
    [Obsolete(
        "The API is currently not stable as it is in the Alpha stage. This attribute will be removed once it is stable.")]
    public override async Task<IAsyncEnumerable<ReadOnlyMemory<byte>>> DecryptAsync(
        string vaultResourceName,
        Stream ciphertextStream,
        string keyName,
        DecryptionOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(vaultResourceName, nameof(vaultResourceName));
        ArgumentNullException.ThrowIfNull(ciphertextStream, nameof(ciphertextStream));
        ArgumentException.ThrowIfNullOrEmpty(keyName, nameof(keyName));

        try
        {
            var decryptionOptions = options ?? new DecryptionOptions();

            var decryptionRequestOptions = new Autogenerated.DecryptRequestOptions
            {
                ComponentName = vaultResourceName, KeyName = keyName
            };

            var grpcCallOptions = DaprClientUtilities.ConfigureGrpcCallOptions(typeof(DaprEncryptionClient).Assembly,
                this.DaprApiToken, cancellationToken);
            var duplexStream = client.DecryptAlpha1(grpcCallOptions);


            var sendTask = Task.Run(() => SendCiphertextStreamAsync(ciphertextStream,
                    decryptionOptions.StreamingBlockSizeInBytes, duplexStream, decryptionRequestOptions,
                    cancellationToken),
                cancellationToken);
            var receiveTask = Task.Run(() =>
                RetrieveDecryptedStreamAsync(duplexStream, cancellationToken), cancellationToken);

            await Task.WhenAll(sendTask, receiveTask).ConfigureAwait(false);
            return receiveTask.Result;
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
            //Ignore our own cancellation
            return AsyncEnumerableExtensions.Empty<ReadOnlyMemory<byte>>();
        }
        catch (RpcException ex) when (ex.StatusCode == StatusCode.Cancelled &&
                                      cancellationToken.IsCancellationRequested)
        {
            //Ignore a remote cancellation due to our own cancellation
            return AsyncEnumerableExtensions.Empty<ReadOnlyMemory<byte>>();
        }
        catch (Exception ex)
        {
            throw new DaprException(
                "Decrypt operation failed: the Dapr endpoint indicated a failure. See InnerException for details",
                ex);
        }
    }

    /// <summary>
    /// Sends the ciphertext bytes in chunks to the sidecar to be decrypted.
    /// </summary>
    private static async Task SendCiphertextStreamAsync(
        Stream ciphertextStream,
        int streamingBlockSizeInBytes,
        AsyncDuplexStreamingCall<Autogenerated.DecryptRequest, Autogenerated.DecryptResponse> duplexStream,
        Autogenerated.DecryptRequestOptions? decryptRequestOptions,
        CancellationToken cancellationToken)
    {
        //Start with passing the metadata about the decryption request itself in the first message
        var request = new Autogenerated.DecryptRequest();
        if (decryptRequestOptions is not null)
        {
            request.Options = decryptRequestOptions;
        }
        await duplexStream.RequestStream.WriteAsync(request, cancellationToken);
        
        //Send the ciphertext bytes in blocks in subsequent messages
        await using (var bufferedStream = new BufferedStream(ciphertextStream, streamingBlockSizeInBytes))
        {
            var buffer = ArrayPool<byte>.Shared.Rent(streamingBlockSizeInBytes);
            try
            {
                int bytesRead;
                ulong sequenceNumber = 0;

                while ((bytesRead = await bufferedStream.ReadAsync(buffer.AsMemory(0, streamingBlockSizeInBytes),
                           cancellationToken: cancellationToken)) != 0)
                {
                    await duplexStream.RequestStream.WriteAsync(
                        new Autogenerated.DecryptRequest
                        {
                            Payload = new Autogenerated.StreamPayload
                            {
                                Data = ByteString.CopyFrom(buffer, 0, bytesRead), Seq = sequenceNumber
                            }
                        }, cancellationToken);

                    //Increment the sequence number
                    sequenceNumber++;
                }
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
        
        //Send the completion message
        await duplexStream.RequestStream.CompleteAsync();
    }

    /// <summary>
    /// Retrieves the decrypted bytes from the decryption operation on the sidecar and returns as an enumerable stream.
    /// </summary>
    private static async IAsyncEnumerable<ReadOnlyMemory<byte>> RetrieveDecryptedStreamAsync(
        AsyncDuplexStreamingCall<Autogenerated.DecryptRequest, Autogenerated.DecryptResponse> duplexStream,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        await foreach (var decryptResponse in duplexStream.ResponseStream.ReadAllAsync(cancellationToken).ConfigureAwait(false))
        {
            yield return decryptResponse.Payload.Data.Memory;
        }
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            this.HttpClient.Dispose();
        }
    }
}
